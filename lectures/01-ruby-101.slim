= slide 'Цели', 'За какво ще говорим днес?' do
  list:
    Какво е Ruby програма и как се изпълнява?
    Как да се справим с документацията в Ruby
    Ръководство за стил
    Как изглеждат нещата, които знаете от други езици, в Ruby

= slide 'Ruby програми' do
  list:
    Ruby е скриптов език
    Програмите в Ruby са текстови файлове
    Няма компилация като в C или Java
    Изпълняват се в терминал/конзола/command prompt с `ruby име_на_файл`

= slide 'irb', 'интерактивна конзола' do
  list:
    `irb` – Interactive Ruby
    REPL — Read-Eval-Print Loop
    Тук се прекарва доста време

= slide 'irb', 'интерактивна конзола' do
  pre
    ' $ irb
      >> 6 * 9
      54
      >> "Ruby! " * 4
      "Ruby! Ruby! Ruby! Ruby!"
      >> -10.abs
      10

= slide 'Документация', 'или как да разберем какво прави нещо в Ruby?' do
  ul
    li <code>ri</code> е инструмент, с който може да разглеждате документацията на клас или метод
    li
       code ri String
       '  показва документацията на класа <code>String</code>
    li
      code ri Numeric#abs
      '  показва документацията на метода <code>abs</code> на класа на числата
    li
      ' Документацията е достъпна онлайн на
      a href="http://ruby-doc.org/" http://ruby-doc.org/
    li
      a href="http://apidock.com" APIDock
      '  е ваш добър приятел

= slide 'Съставните части на една Ruby програма', 'ръководство по ориентиране' do
  list:
    Синтаксис (вкл. и ключови думи)
    Ключови думи `if`, `def`, `class`, `defined?` и още дузина-две
    Ядро (core) – [http://ruby-doc.org/core/](http://ruby-doc.org/core/)
    Стандартна библиотека (stdlib) – [http://ruby-doc.org/stdlib/](http://ruby-doc.org/stdlib/)
    Нещата от стандартната библиотека се инсталират с Ruby, но трябва да ги заредите с `require`

= slide 'Стил' do
  ul
    li.action В момента говорим за "форматиране на кода", а не за дизайн
    li.action Прегледайте <a href="https://github.com/bbatsov/ruby-style-guide">Ruby Style Guide</a> на г-н Бацов
    li.action Накрая ще минем по него.
    li.action Цитат: "Ако не можете да си подреждате кода, ориентирайте се към друга професия. Например строителство."
    li.action Yoda: "Unexpected this is. And unfortunate."

= slide 'Извеждане на екрана', 'или как да досаждате на хората с текст' do
  ul
    li.action Става с <code>puts</code>
    li.action Например <code>puts "Chunky bacon!"</code>
    li.action <code>puts</code> не е ключова дума, а "глобална" функция
    li.action Може да се извика и със скоби: <code>puts("Chunky bacon!")</code>
    li.action Последното важи за всички функции в Ruby

= slide 'Имена и неща', '...или разликата между нещо и неговите имена' do
  p
    ' <code>=</code> не копира стойността, а насочва променливата към обекта отдясно

  pre
    ' >> word = "oat"
      >> breakfast = word
      >> dinner = word
      >> word.insert(0, 'g')
      >> puts breakfast
      goat

= slide 'Действия', 'още известни като "методи"' do
  pre
    ' >> "shut up".upcase()
      →  "SHUT UP"
      >> "wonderful".sub("wonder", "color")
      →  "colorful"
      >> 3.14.floor
      →  3
      >> 24.gcd 56
      →  8
      >> 'wonderful'.sub 'wonde', 'colo'
      →  "colorful"

= slide 'Видове променливи' do
  example:
    favourite = 'Chunky bacon' # локална
    Tax = '20%'                # константа
    $important = 'Money'       # глобална

  p Има още: <code>@name</code> и <code>@@name</code>

= slide 'Ключови думи', 'Вече заети' do
  pre
    ' alias    and      BEGIN    begin      break
      case     class    def      defined?   do
      else     elsif    END      end        ensure
      false    for      if       in         module
      next     nil      not      or         redo
      rescue   retry    return   self       super
      then     true     undef    unless     until
      when     while    yield

= slide 'Основни типове', '1/2' do
  ul
    li.action Цели числа &mdash; <code>42</code>, <code>-271</code>, <code>1_024</code>
    li.action Низове &mdash; <code>"chunky"</code>, <code>'bacon'</code>
    li.action С плаваща запетая &mdash; <code>3.1415</code>
    li.action Булеви &mdash; <code>true</code> и <code>false</code>
    li.action Нищо &mdash; <code>nil</code>
    li.action Масиви &mdash; <code>[2, 3, 5, 7, 11]</code>

= slide 'Основни типове', '2/2' do
  ul
    li.action Символи &mdash; <code>:name</code>, <code>:send</code>
    li.action Хешове &mdash; <code>{'one' => 1, 'two' => 2}</code> или със символи <code>{one: 1, two: 2}</code>
    li.action Регулярни изрази &mdash; <code>/(bb)|([^b]{2})/</code>
    li.action Области &mdash; <code>2..6</code>, <code>'a'...'z'</code>
    li.action Анонимни функции &mdash; <code>lambda { |x| x ** 2 }</code>, <code>-> x { x ** 2 }</code>
    li.action Обекти &mdash; <code>Person.new</code>

= slide 'Цели числа' do
  example:
    0
    1729
    -271
    1_000_000
    0377        # осмични
    0b0100_0010 # двоични
    0xDEADBEEF  # шестнадесетични

= slide 'Числа с плаваща запетая' do
  example:
    0.0
    3.14
    -273.15
    1.22e28
    1_000.001

= slide 'Текст' do
  example:
    'Chunky bacon, I say!'
    "Who is John Galt?"
    "We're the knights who say \"Ni!\""
    '\'0 freddled gruntbugly\' he begun'
    'This text contains\nno newlines'
    "This text contains\none newline"
    %(Look ma "I" can 'qoute')

= slide 'Операции с текст' do
  pre
    ' >> "Hello, " + " " + "chunky!"
      →  "Hello,  chunky!"
      >> "Ha! " * 3
      →  "Ha! Ha! Ha! "
      >> "%s bacon" % 'Chunky'
      →  "Chunky bacon"
      >> text = 'Chanky'
      >> text[2] = 'u'
      >> text << ' bacon'
      >> puts text
      Chunky bacon

= slide 'Още операции с текст' do
  annotate:
    "bacon\n".chop            #=>
    "bacon".chop              #=>
    "bacon\n".chomp           #=>
    "bacon".chomp             #=>
    "Goodbye".include? 'oo'   #=>
    "Danube".length           #=>
    "oat".insert 0, 'bl'      #=>
    "bloat".sub "bl", "m"     #=>
    "bacon".upcase            #=>
    "BaCoN".downcase          #=>

= slide 'Интерполация' do
  p Работи при двойни кавички, не работи при единични

  example:
    character = 'Arthur'
    answer = 42
    puts '#{character} had it: #{answer}'   # '#{character} had it: #{answer}'
    puts "#{character} had it: #{answer}"   # 'Arthur had it: 42'
    puts %(#{character} had it: #{answer})  # 'Arthur had it: 42'
    puts %q(#{character} had it: #{answer}) # '#{character} had it: #{answer}'
    puts %Q(#{character} had it: #{answer}) # 'Arthur had it: 42'

= slide 'Символи', '...което ще ви обърка' do
  ul
    li.action Малко особен тип в Ruby
    li.action <code>:something</code>, <code>:other</code> и <code>:larodi</code>
    li.action Сходен на низ &mdash; immutable и интерниран
    li.action Различни приложения
    li.action Не го мислете много

= slide 'Оператори', '...или как да оперирате с Ruby' do
  pre
    ' **  ~   /   %    +    -    &
      <<  >>  |   ^    >    <    >=   <=   <=>
      &&  ||  !   and  or   not  ||=  &&=
      =   +=  -=  *=   /=   %=   **=  >>=  <<=
      ^=  &=  |=  ..   ...  defined?

= slide 'Истина и лъжа', '...където става философско' do
  ul
    li.action <code>nil</code> се оценява като "лъжа"
    li.action <code>false</code> се оценява като "лъжа" (очевидно)
    li.action всичко друго е истина
    li.action <code>0</code>, <code>""</code> и <code>[]</code> са истина

= slide 'Булеви оператори' do
  ul
    li.action <code>and</code>, <code>or</code> и <code>not</code> правят това, което очаквате
    li.action <code>&&</code>, <code>||</code> и <code>!</code> &mdash; също
    li.action Разликата между тях е тънка. Придържайте се към първите

= slide 'Сравнение' do
  pre
    ' >> 20 > 20
      →  false
      >> "perl" < "ruby"
      →  true
      >> 5 <= 5
      →  true
      >> "foo" <=> "bar"
      →  1

= slide 'Равенство', '...където става оплетено' do
  p В Ruby има четири оператора за равенство

  example:
    one == two      # нормално равно
    one === two     # използва се в case
    one.eql? two    # използва се за Hash
    one.equal? two  # дали обектът е един и същ

= slide 'Равенство', '== и equal?' do
  p Това е стандартното поведение на Ruby. Има специални случаи.
  annotate:
    one = 'chunky bacon'
    two = 'chunky bacon'
    one == two           #=>
    one.equal? two       #=>

= slide 'Равенство', 'Специалните случаи' do
  p Можете ли да произнесете "интерниране"?

  annotate:
    one, two = 42, 42
    one == two      #=>
    one.equal? two  #=>

  p Същото важи и за символи.

= slide 'Условия' do
  p Ключовата дума е <code>if</code> ;)

  example:
    if hungry?
      eat
    elsif thirsty?
      drink
    else
      listen_to_music
    end

= slide 'Условия', '...където научавате, че всяко условие е израз' do
  example:
    classification = if age < 13
                       'young person'
                     elsif age < 20
                       'teenager'
                     else
                       'old dude'
                     end

= slide 'Условия', 'на един ред' do
  example:
    eat if hungry?

  p Яко, а? Може и:

  example:
    order = if hungry? then 'food' else 'coffee' end # което е :/
    order = hungry? ? 'food' : 'coffee' # win

= slide 'Условия', 'освен ако' do
  p <code>unless</code> е като <code>if not</code>.
  p Всичко за <code>if</code> е приложимо
  p Не ползвайте <code>unless</code> с <code>else</code> (style warning!)

  example:
    unless tired?
      go_out_and_run
    end

= slide 'case', "т.е. 'switch'-а на Ruby" do
  example:
    case
    when song.name == 'Misty'
      puts 'Not again!'
    when song.duration > 120
      puts 'Too long!'
    when Time.now.hour > 21
      puts "It's too late"
    else
      song.play
    end

= slide 'case', 'израз съм.. връщам резултат' do
  example:
    kind = case year
           when 1850..1889 then 'Blues'
           when 1890..1909 then 'Ragtime'
           when 1910..1929 then 'New Orleans Jazz'
           when 1930..1939 then 'Swing'
           when 1940..1950 then 'Bebop'
           else 'Jazz'
           end

= slide 'Функции' do
  p Всъщност това са методи. Скоро ще разберете защо.
  p Дефинират се с <code>def</code>.

  example:
    def eat_chocolate
      puts 'nom nom nom'
    end

  pre
    ' $ irb
      >> eat_chocolate
      →  nil
      nom nom nom

= slide 'Функции', 'резултати' do
  p Всеки метод връща резултат - последният израз в него.

  annotate:
    def add(a, b)
      a + b
    end

    add(5, 10) #=>

= slide 'Функции', 'резултати' do
  p Това важи и за по-сложни изрази.

  annotate:
    def max(a, b)
      if a > b
        a
      else
        b
      end
    end

    max(1, 5) #=>

  p Има и ключова дума <code>return</code> - използвайте я само в краен случай.

= slide 'Масиви', 'типичните методи' do
  annotate:
    numbers = [3, 1, 2, 4]
    numbers[1]      # =>
    numbers[-1]     # =>
    numbers.length  # =>
    numbers.size    # =>
    numbers.sort    # =>
    numbers.reverse # =>
    numbers[1..2]   # =>

  p <code>sort</code> и <code>reverse</code> връщат нов масив, без да променят <code>numbers</code>.

= slide 'Масиви', 'забавни оператори' do
  annotate:
    [:a, :b, :c] + [:d, :e]             # =>
    [:a, :b, :c, :b, :a] - [:b, :c, :d] # =>
    [:a, :b, :c] & [:b, :c, :d]         # =>
    [:a, :b, :c] | [:b, :c, :d]         # =>

  p <code>&</code> и <code>|</code> конкатенират списъците и премахват повторенията.
  p В Ruby има множества, които са по-удачни в повечето случаи.

= slide 'Масиви', 'мутиране' do
  annotate:
    numbers = [1, 2, 3]

    numbers << 4
    p numbers   # =>

    numbers.insert 0, :zero
    p numbers   # =>

    result = numbers.delete_at(0)
    p result    # =>
    p numbers   # =>

= slide 'Масиви', 'push и pop' do
  annotate:
    stack = [1, 2, 3]

    stack.push 4
    p stack         # =>

    top = stack.pop
    p stack         # =>
    p top           # =>

  p <code>#shift</code> и <code>#unshift</code> са аналогични, но работят с началото на масива.

= slide 'Масиви', 'итерация' do
  p Итерира се с <code>#each</code>, както всичко останало в Ruby:
  example:
    primes = [2, 3, 5, 7, 11]

    primes.each { |n| puts n }

    primes.each do |n|
      puts n
    end

= slide '"Къдрави скоби" и do/end' do
  ul
    li.action По конвенция, фигурни скоби се ползват, когато целият блок е на един ред
    li.action <code>do</code>/<code>end</code> се ползва, когато блокът е няколко реда

= slide 'Хешове' do
  list:
    Важна част в програмирането на Ruby
    Майсторското овладяване е задължително!
    Още: хеш таблици, асоциативен списък, речник, map

= slide 'Хешове', 'общи факти' do
  list:
    Класът е `Hash`, но има и литерален синтаксис – `{}`
    Дефинират се така: `{1 => :one, 2 => :two}`
    Ключовете трябва да могат да се хешират: числа, низове, символи, списъци
    По възможност, ключовете трябва да са immutable
    Редът на ключовете се запазва

= slide 'Хешове', 'индексиране' do
  annotate:
    numbers = {:one => :eins, :two => :zwei}

    numbers[:one]     # =>
    numbers[:three]   # =>

    numbers[:three] = :drei

    numbers[:three]                     # =>
    numbers.fetch(:four, :keine_ahnung) # =>
    numbers.fetch(:four)                #!

= slide 'Хешове', 'итерация' do
  annotate:
    numbers = {:one => :eins, :two => :zwei}
    numbers.keys    # =>
    numbers.values  # =>

    numbers.each { |pair| puts pair }
    numbers.each { |key, value| puts key, value }

= slide 'Хешове', 'разни методи' do
  annotate:
    numbers = {1 => 2, 3 => 4}

    numbers.has_key?(:three) # =>
    numbers.size             # =>
    numbers.invert           # =>
    numbers.merge({5 => 6})  # =>
    numbers.to_a             # =>
    Hash[1, 2, 3, 4]         # =>

= slide 'Хешове', 'алтернативен синтаксис' do
  p Долните два реда произвеждат еднакви хешове. Второто е по-весело:

  example:
    {:one => 1, :two => 2}
    {one: 1, two: 2}

  p Има интересна врътка при извикването на методи.

= slide 'Списъци и хешове', 'накратко' do
  list:
    И като цяло всичко, що може да се обхожда (т.е. е [`Enumerable`](http://ruby-doc.org/core-2.2.3/Enumerable.html))
    Ползват се <strong>постоянно</strong>
    Трябва да ги владеете много добре
    Това е едва върхът на айсберга

= slide 'map', 'едва върхът на айсберга' do

  annotate:
    numbers = 1..6
    numbers.map { |n| n * 2 }   # =>
    numbers.map { |n| {n: n} }  # =>
    numbers.map { |n| n.even? } # =>
    numbers.map(&:even?)        # =>

= slide 'select' do

  annotate:
    numbers = [1, 2, 3, 4, 42]
    numbers.select { |n| n > 3 }   # =>
    numbers.select { |n| n.even? } # =>
    numbers.select(&:odd?)         # =>

= slide 'Методи', 'отгоре-отгоре' do
  list:
    В Ruby няма такова нещо като "глобална функция"
    `def` винаги дефинира метод в някакъв клас
    Ако `def` не е в дефиниция на клас, отива като `private` метод на `Object`
    `puts` е пример за нещо такова, както и методите, които дефинирате в irb
    Дефинирането на методи в `Object` е удачно само за кратки скриптове
    Отвъд тях, дефинирането на методи в `Object` е <strong>ужасно</strong> лош стил

= slide 'Методи', 'return' do
  p Можете да излезете от функция с <code>return</code>:

  example:
    def includes?(array, element)
      array.each do |item|
        return true if item == element
      end
      false
    end

  p.action
    ' Разбира се, такава функция е излишна.
      Може да ползвате <code>array.include?(element)</code>.

= slide 'Методи', 'стойности по подразбиране' do
  p Параметрите в Ruby могат да имат стойности по подразбиране:

  annotate:
    def order(drink, size = 'large')
      "A #{size} #{drink}, please!"
    end

    order 'tea'             # =>
    order 'coffee', 'small' # =>

= slide 'Методи', 'стойности по подразбиране (2)' do
  list:
    Стойностите по подразбиране могат да бъдат всякакъв израз
    "Всякакъв израз" включва и извикване на друга функция
    Оценяват се на всяко извикване
    Сложни изрази за аргументи по подразбиране са лош стил

= slide 'Методи', 'променлив брой аргументи' do
  p
    | Методите в ruby могат да вземат променлив брой аргументи. Параметърът се означава със
      <code>*</code> и при извикване на функцията съдържа списък от аргументите.

  annotate:
    def say_hi(name, *drinks)
      "Hi, I am #{name} and I enjoy: #{drinks.join(', ')}"
    end

    say_hi 'Goshko', 'coffee', 'tea', 'water' # =>

= slide 'Ruby и ООП' do
  list:
    Всичко е обект
    Duck typing
    Няма функции, има само методи
    Няма множествено наследяване, но има mixin-и

= slide 'Методи', 'променлив брой аргументи' do
  p Параметърът за променлив брой аргументи може да е на всяка позиция в дефиницията:

  example:
    def something(*a, b, c)
    end

    def something(a, *b, c)
    end

  p Очевидно, може да има само един такъв параметър във функция.

= slide 'Методи', '...и техните приятели, хешовете' do
  p
    ' Когато последният аргумент е хеш, може да изтървете фигурните скоби около него.
      Долните редове правят едно и също:

  example:
    def order(drink, preferences)
    end

    order('Latte', {:size => 'grande', :syrup => 'hazelnut'})
    order 'Latte', {:size => 'grande', :syrup => 'hazelnut'}
    order 'Latte', :size => 'grande', :syrup => 'hazelnut'
    order 'Latte', size: 'grande', syrup: 'hazelnut'

  p Така Ruby симулира извикване на функция с наименовани аргументи.

= slide 'Методи', '...и хешове, отново' do
  p Често ще видите код в този вид:

  example:
    def order(drink, preferences = {})
    end

    order 'Latte'
    order 'Latte', size: 'grande', syrup: 'hazelnut'

  p
    ' Така <code>preferences</code> е незадължителен и няма нужда да го подавате, ако
      нямате предпочитания.

= slide '**kwargs' do
  example:
    def order(drink:, size: 'grande', **options)
      message = "You ordered a #{size} #{drink}"
      message << " with these options: #{options.inspect}" unless options.empty?
      message
    end

    order drink: 'Latte'
    # You ordered a grande Latte
    order syrup: 'hazelnut', drink: 'Latte'
    # You ordered a grande Latte with these options: {:syrup=>"hazelnut"}
    order
    # error: ArgumentError: missing keyword: drink

= slide 'Истински keyword arguments', 'предимства' do
  list:
    Ако има стойност по подразбиране, тя се задава редом с дефиницията на метода
    Ползвате стойността на аргумента директно, няма нужда от отделна променлива
    Непознати ключови думи, подадени като аргументи, предизвикват грешка
    Липсващи и задължителни ключови думи за аргументи също предизвикват грешка

= slide 'Методи', 'предикати' do
  p
    ' Името на метод може да завършва на <code>?</code>. Това се ползва за методи,
      които връщат лъжа или истина (предикати):

  example:
    def even?(n)
      n % 2 == 0
    end

    even? 2
    even? 3

  p Това е само конвенция.

= slide 'Методи', 'две версии' do
  p
    ' Името на метод може да завършва на <code>!</code>.
      Това се ползва, когато <strong>методът има две версии с различно поведение</strong>:

  example:
    numbers = [4, 1, 3, 2, 5, 0]

    numbers.sort   # връща нов списък
    numbers.sort!  # променя списъка на място

  p В случая, "по-опасният" метод завършва на удивителна.
  p Ако имате само една версия на метод с такова име, не слагайте удивителна.


= slide 'Псевдо-keyword arguments', 'недостатъци' do
  p Този "трик" с хешовете се ползва много, понякога прекалено много. Той има и ред недостатъци:

  list:
    За да ползвате стойност, трябва да я достъпите през променлива (например `preferences[:size]`)
    Задаването на стойности по подразбиране е криво и може да се прави само в тялото на метода
    Например така: `preferences[:size] ||= 'grande'`
    Или така: `preferences = {size: 'grande', syrup: 'hazelnut'}.merge(preferences)`
    Проверката за задължителни keyword args става пак ръчно
    Проверката дали някой не ви е подал "излишни" и непознати ключови думи за аргументи – пак ръчно

= slide 'Истински keyword arguments' do
  p Горните недостатъци и нуждата водят до появата на истински keyword arguments в Ruby 2.0.

  annotate:
    def order(drink, size: 'grande', syrup: nil)
      message = "You ordered a #{size} #{drink}"
      message << " with a #{syrup} syrup" if syrup
      message
    end

    order 'Latte'                       # =>
    order 'Latte', syrup: 'hazelnut'    # =>
    order 'Latte', filling: 'chocolate' #!

= slide 'Задължителни keyword arguments' do
  example:
    def order(drink:, size: 'grande', syrup: nil)
      message = "You ordered a #{size} #{drink}"
      message << " with a #{syrup} syrup" if syrup
      message
    end

    order drink: 'Latte'                    # "You ordered a grande Latte"
    order syrup: 'hazelnut', drink: 'Latte' # "You ordered a grande Latte with a hazelnut syrup"
    order                                   # error: ArgumentError: missing keyword: drink

= slide 'Анонимни функции', 'ламбди' do
  p
    ' Анонимни функции в Ruby се дефинират с <code>lambda</code>. Имат три начина на извикване:

  example:
    pow = lambda { |a, b| a**b }

    pow.call 2, 3
    pow[2, 3]
    pow.(2, 3)

  p
    ' За нещастие, не може да извиквате така: <code>double(2)</code>. Това е несъвместимо с
      изтърваването на скобите при извикването на метод.

= slide 'Анонимни функции', 'ламбди (2)' do
  p Може и така:

  example:
    double = lambda do |x|
      x * 2
    end

  p Важи стандартната конвенция за <code>{ }</code> и <code>do</code>/<code>end</code>.

= slide 'Анонимни функции', 'ламбди (3)' do
  p От 1.9 има по-симпатичен синтаксис за ламбди:

  example:
    say_hi = lambda { puts 'Hi there!' }
    double = lambda { |x| x * 2 }
    divide = lambda { |a, b| a / b }

    say_hi = -> { puts 'Hi there' }
    double = ->(x) { x * 2 }
    divide = -> a, b { a / b }

= slide 'Блокове', 'където става забавно' do
  p
    ' Всеки метод може да приеме допълнителен аргумент, който е "анонимна функция". Може да
      го извикате от метода с <code>yield</code>:

  example:
    def twice
      yield
      yield
    end

    twice { puts 'Ruby rocks!' }

= slide 'Блокове', 'аргументи' do
  p Блокът може да приема аргументи:

  example:
    def sequence(first, last, step)
      current = first
      while current < last
        yield current
        current += step
      end
    end

    sequence(1, 10, 2) { |n| puts n }
    # Извежда 1, 3, 5, 7, 9

= slide 'Блокове', 'стойности' do
  p <code>yield</code> се оценява до стойността на блока:

  annotate:
    def calculate
      result = yield(2)
      "The result for 2 is #{result}"
    end

    calculate { |x| x**2 } # =>

= slide 'Блокове', 'един пример' do
  p Или как можем да напишем <code>filter</code>:

  annotate:
    def filter(array)
      result = []
      array.each do |item|
        result << item if yield item
      end
      result
    end

    filter([1, 2, 3, 4, 5]) { |n| n.odd? } # =>

  .action
    p Разбира се, такъв метод в Ruby вече съществува – <code>Enumerable#select</code>.

= slide 'Класове', 'прост пример' do
  p
    | Дефинират се с <code>class</code>. Методите, дефинирани в тялото на класа,
      стават методи на инстанциите му. Инстанцират се с <code>ИмеНаКласа.new</code>.

  annotate:
    class Bacon
      def chunky?
        'yes, of course!'
      end
    end

    bacon = Bacon.new
    bacon.chunky?      # =>

= slide 'Класове', 'полета' do
  p Полетата (още: instance variables) имат представка <code>@</code>.

  annotate:
    class Vector
      def initialize(x, y)
        @x = x
        @y = y
      end

      def length
        (@x * @x + @y * @y)**0.5
      end
    end

    vector = Vector.new 2.0, 3.0
    vector.length()     # =>
    vector.length       # =>

= slide 'Класове', 'полета (2)' do
  p По подразбиране имат стойност <code>nil</code>.

  example:
    class Person
      def soul
        @nothingness
      end
    end

    person = Person.new
    person.soul      # nil

= slide 'Класове', 'викане на методи' do
  p
    ' В метод може да извикате друг със <code>self.име_на_метод</code>
      или просто <code>име_на_метод</code>:

  example:
    class Person
      def initialize(name) @name = name                end
      def say_hi()         puts "My name is #{@name}!" end
      def sound_smart()    puts "1101000 1101001"      end

      def talk
        self.say_hi
        sound_smart
      end
    end

    mel = Person.new 'Mel'
    mel.talk

  p Такова подравняване на методи е гадно, но пък се събира в слайд.

= slide 'Класове', 'self' do
  p
    ' В методите на класа, <code>self</code> е референция към обекта,
      на който е извикан методът. Като <code>this</code> в Java или C++.

  annotate:
    class Person
      def me
        self
      end
    end

    person = Person.new
    person           # =>
    person.me        # =>
    person.me.me     # =>

= slide 'Атрибути', 'setter-и' do
  annotate:
    class Person
      def age
        @age
      end

      def age=(value)
        @age = value
      end
    end

    person = Person.new
    person.age = 33  # Същото като person.age=(33)

    person.age       # =>

= slide 'Атрибути', 'attr_accessor' do
  p Последното е досадно за писане. Затова:

  annotate:
    class Person
      attr_accessor :age
    end

    person = Person.new
    person.age = 33

    person.age # =>

= slide 'Атрибути', 'другите макроси' do
  p Ако ви трябва само getter или setter, може така:

  example:
    class Person
      attr_reader :name
      attr_writer :grade
      attr_accessor :age, :height
    end

= slide 'Модули' do
  p Модулите в Ruby имат няколко предназначения:

  ul
    li Именовани пространства
    li Съдържане на "не-instance" методи
    li Mixins

  p Днес ще разгледаме последното.

= slide 'Модули', 'като колекция от методи' do
  p Модулите в Ruby просто съдържат методи. Дефинират се подобно на класове:

  example:
    module UselessStuff
      def almost_pi
        3.1415
      end

      def almost_e
        2.71
      end
    end

= slide 'Модули', 'миксиране' do
  p
    ' Модулите могат да се "миксират" с клас. Тогава той получава всички методи
      на модула като инстанционни методи.

  annotate:
    module UselessStuff
      def almost_pi
        3.1415
      end
    end

    class Something
      include UselessStuff
    end

    Something.new.almost_pi # =>

= slide 'Модули', 'self' do
  p
    ' В метод на модула, <code>self</code> е инстанцията от класа, в който модулът е бил миксиран и на която е извикан даденият метод.

  annotate:
    module Introducable
      def introduction
        "Hello, I am #{name}"
      end
    end

    class Person
      include Introducable
      def name() 'The Doctor' end
    end

    doctor = Person.new
    doctor.introduction # =>

= slide 'Модули', 'приоритет на методите' do
  p Методите на класа имат приоритет пред методите на модула.

  annotate:
    module Includeable
      def name() 'Module' end
    end

    class Something
      def name() 'Class' end
      include Includeable
    end

    Something.new.name # =>

= slide 'Модули', 'приоритет на методите (2)' do
  p Ако два модула дефинират един и същи метод, ползва се методът от последно миксирания модул:

  annotate:
    module Chunky
      def name() 'chunky' end
    end

    module Bacon
      def name() 'bacon' end
    end

    class Something
      include Chunky
      include Bacon
    end

    Something.new.name # =>

= slide 'Модули', 'приоритет на методите (3)' do
  p Просто за информация: методите на mixin-ите имат приоритет пред тези на родителя.
  p Всичко това е свързано с нещо, наречено <em>ancestor chain</em>. Грубо:

  annotate:
    Array.ancestors              # =>
    Array.ancestors.map(&:class) # =>

